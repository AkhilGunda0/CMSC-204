/*
 * Class: CMSC204
 * CRN:21078
 * Instructor: Monshi
 * Description: Dijkstra's algorithm for shortest path between two vertices
 * Due: 5/10/23
 * Platform/compiler: Eclipse
 * I pledge that I have completed the programming 
 * assignment independently. I have not copied the code 
 * from a student or any source. I have not given my code 
 * to any student.
   Print your Name here: __Akhil Gunda______
*/

import java.util.*;

public class Graph implements GraphInterface<Town, Road> {

	//set of towns = vertices
	Set<Town> towns;
	//set of roads = edges
	Set<Road> roads;
	//shortest map 
	Map<Town, Road> shortestMap;
	
	//default constructor
	public Graph() {
		towns = new HashSet<Town>();
		roads = new HashSet<Road>();
		shortestMap = new HashMap<>();
	}
	
	//constructor with all fields
	public Graph(Set<Town> towns, Set<Road> roads, Map<Town, Road> shortestMap) {
		super();
		this.towns = towns;
		this.roads = roads;
		this.shortestMap = shortestMap;
	}
	
	//constructor with towns, roads, and no shrotestmap
	public Graph(Set<Town> towns, Set<Road> roads) {
		super();
		this.towns = towns;
		this.roads = roads;
		this.shortestMap = new HashMap<>();
	}

	//getters and setters
	//get roads
	public Set<Road> getRoads() {
		return roads;
	}
	//set roads
	public void setRoads(Set<Road> roads) {
		this.roads = roads;
	}

	//get shortest map
	public Map<Town, Road> getShortestMap() {
		return shortestMap;
	}
	// set shortest map
	public void setShortestMap(Map<Town, Road> shortestMap) {
		this.shortestMap = shortestMap;
	}
	//set towns
	public void setTowns(Set<Town> towns) {
		this.towns = towns;
	}

	//get towns
	public Set<Town> getTowns(){
		return this.towns;
	}
	//autogenerated hashcode
	@Override
	public int hashCode() {
		return Objects.hash(roads, shortestMap, towns);
	}

	//autogenerated equals method
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Graph other = (Graph) obj;
		return Objects.equals(roads, other.roads) && Objects.equals(shortestMap, other.shortestMap)
				&& Objects.equals(towns, other.towns);
	}
	
	//autogenerated tostring method
	@Override
	public String toString() {
		return "Graph [towns=" + towns + ", roads=" + roads + ", shortestMap=" + shortestMap + "]";
	}
	
	//get road that connects one town to another town
	@Override
	public Road getEdge(Town sourceVertex, Town destinationVertex) {
		int numOfRoads = this.roads.size();
		Iterator<Road> it = roads.iterator();
		
		for (int i = 0; i < numOfRoads; i++) {
			Road r = it.next();
			if (r.hasEndpoint(sourceVertex) && r.hasEndpoint(destinationVertex)) {
				Road rr = new Road(sourceVertex, destinationVertex, r.getDistance(), r.getName());
				return rr;
			}
		}
		return null;
	}

	@Override
	public Road addEdge(Town sourceVertex, Town destinationVertex, int weight, String description) {
		if (sourceVertex == null || destinationVertex == null) {
			throw new NullPointerException("throwing null pointer exception");
		}
		else if (!towns.contains(sourceVertex) || !towns.contains(destinationVertex)) {
			throw new IllegalArgumentException("doesn't have endpoint");
		}
		Road newEdge = new Road(sourceVertex, destinationVertex, weight, description);
		if (this.containsEdge(sourceVertex, destinationVertex)) {
			return null;
		}
		else {
			roads.add(newEdge);
			return newEdge;
		}
	}

	@Override
	public boolean addVertex(Town v) {
		//check size
		int currentSize = towns.size();
		//add vertex
		towns.add(v);
		//new size should be 1 larger if vertex added
		int newSize = towns.size();
		//if size is same, vertex not added return false
		if (currentSize == newSize){
			return false;
		}
		//if vertex added, newsize> current size and return true
		else {
			return true;
		}
		
	}

	@Override
	public boolean containsEdge(Town sourceVertex, Town destinationVertex) {
		Road compareRoad= new Road(sourceVertex, destinationVertex, "");
		int numOfRoads = roads.size();
		Iterator<Road> it = roads.iterator();
		for (int i = 0; i < numOfRoads; i++) {
			Road r = it.next();
			if(r.equals(compareRoad)) {
				return true;
			}
		}
		return false;
	}

	@Override
	public boolean containsVertex(Town v) {
		Iterator<Town> it = towns.iterator();
		for (int i = 0; i < towns.size(); i++) {
			Town t = it.next();
			if (t.equals(v)) {
				return true;
			}
		}
		return false;
	}

	@Override
	public Set<Road> edgeSet() {
		return this.roads;
	}

	//returns set of adjacent edges to vertex
	@Override
	public Set<Road> edgesOf(Town vertex) {
		if (vertex == null) {
			throw new NullPointerException("throwing null pointer exception");
		}
		else if (!(this.towns).contains(vertex)) {
			throw new IllegalArgumentException("throwing illegal argument exception");
		}
		Set <Road> adj = new HashSet<Road>();
		Iterator<Road> it = roads.iterator();
		for (int i = 0; i < roads.size(); i++) {
			Road r = it.next();
			if (r.hasEndpoint(vertex)) {
				adj.add(r);
			}
		}
		return adj;
	}

	//removes edge from graph
	@Override
	public Road removeEdge(Town sourceVertex, Town destinationVertex, int weight, String description) {
		Road r = new Road(sourceVertex, destinationVertex, weight, description);
		Iterator<Road> it = roads.iterator();
		
		while (it.hasNext()) {
			Road rr = it.next();
			if(rr.equals(r)) {
				if(weight > -1 && rr.getDistance() != weight) {
					continue;
				}
				else if (description != null && !rr.getName().equals(description)) {
					continue;
				}
				roads.remove(rr);
				return rr;
			}
		}
		return null;
	}

	@Override
	public boolean removeVertex(Town v) {
		Boolean b = true;
		//removes vertex if it is contained in graph
		if (!towns.contains(v)) {
			b = false;
			return b;
		}
		else {
			b= true;
			towns.remove(v);
		}
		//need to remove connecting edges
		Iterator<Road> it = roads.iterator();
		Set<Road> roadsCopy = new HashSet<Road>();
		roadsCopy.addAll(roads);
		
		while(it.hasNext()) {
			Road road = it.next();
			if (road.hasEndpoint(v)) {
				it.remove();
			}
		}
		return b;
	}

	@Override
	public Set<Town> vertexSet() {
		return this.towns;
	}

	@Override
	public ArrayList<String> shortestPath(Town sourceVertex, Town destinationVertex) {
	    dijkstraShortestPath(sourceVertex);
	    ArrayList<String> shortestArr = new ArrayList<String>();

	    Road data = shortestMap.get(destinationVertex);
	    if (data == null) {
	        return shortestArr; // no path from source to destination
	    }

	    buildShortestPath(shortestArr, data, sourceVertex);
	    return shortestArr;
	}

	//recursive method to implement shortestPath
	private void buildShortestPath(ArrayList<String> shortestArr, Road data, Town sourceVertex) {
	    if (data.getStart().equals(sourceVertex)) {
	    	String route = data.getStart() + " via " + data.getName() + " to " + data.getDestination() + " " + data.getWeight() + " mi";
	        shortestArr.add(route);
	        return;
	    }
	    buildShortestPath(shortestArr, shortestMap.get(data.getStart()), sourceVertex);
	    String route = data.getStart() + " via " + data.getName() + " to " + data.getDestination() + " " + data.getWeight() + " mi";
	    shortestArr.add(route);
	}
	
	@Override
	public void dijkstraShortestPath(Town sourceVertex) {
		//create Map
		Map<Town, Road> shortestMap = new HashMap<>();
		
		Iterator<Town> it = towns.iterator();
		while (it.hasNext()) {
			Town town = it.next();
			Road road = new Road(sourceVertex, town, Integer.MAX_VALUE, "temp");
			shortestMap.put(town, road);
		}
		
		//Town queue
		Queue<Town> queue = new LinkedList<Town>();
		
		//prev Queue
		Set <Town> searched = new HashSet<Town>();
		
		//add first town to map
		Road road = new Road(sourceVertex, sourceVertex, 0, "start");
		shortestMap.put(sourceVertex, road);
		
		//add to queues
		queue.add(sourceVertex);
		searched.add(sourceVertex);
		
		while(!queue.isEmpty()) {
			Town current = queue.remove();
			Iterator<Road> it2 = roads.iterator();
			while(it2.hasNext()) {
				Road road2 = it2.next();
				if (road2.hasEndpoint(current)) {
					Town source = current;
					Town destination = road2.getOtherTown(road2, source);
					if (searched.contains(destination)) {
						//do nothign
					}
					else {
						queue.add(destination);
						searched.add(destination);
					}
					int upto = road2.getDistance();
					Town temp = source;
					while(!temp.equals(sourceVertex)) {
						int weight = shortestMap.get(temp).getDistance();
						Town start = shortestMap.get(temp).getStart();
						upto += weight;
						temp = start;
					}
					int prev = 0;
					temp = destination;
					while(!temp.equals(sourceVertex)) {
						int weight = shortestMap.get(temp).getDistance();
						Town start = shortestMap.get(temp).getStart();
						prev += weight;
						temp = start;
					}
					Road r3 = new Road(source, destination, road2.getDistance(), road2.getName());
					if (upto < prev) {
						shortestMap.put(destination, r3);
					}
				}
			}
		}
		this.shortestMap = shortestMap;
	}

}
